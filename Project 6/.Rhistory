##########################
## Simulation I: NEAREST #
##########################
# Remove post-treatment covariates
filtered_vars <- names(ypsps)[!grepl("1973|1982", names(ypsps))]
baseline_df <- ypsps %>% select(all_of(filtered_vars)) %>%
filter(!is.na(parent_GPHighSchoolPlacebo))
baseline_df <- baseline_df[complete.cases(baseline_df), ]
## generating df with complete cases for function used below
set.seed(3141)
simulate_and_get_att_nearest <- function(num_simulations) {
## Initializing empty lists
att_list <- numeric(num_simulations)
prop_balanced_covariates <- numeric(num_simulations)
summary_df <- list()
num_covariates <- list()
mean_pct_improvement <- numeric(num_simulations)
match_nearest <- vector("list", length = num_simulations)
# Simulate samples, perform propensity score matching, and calculate ATT
for (i in 1:num_simulations) {
num_covariates[[i]] <- sample(5:20, 1) # Randomly choose the number of covariates
available_cols <- setdiff(names(baseline_df), c('college', 'student_ppnscal'))
sample_size <- min(num_covariates[[i]] + 2, length(available_cols))
sampled_cols <- sample(available_cols, sample_size)
sampled_data <- baseline_df[, c(sampled_cols, "college", "student_ppnscal"), drop = FALSE]
# sampled df with sampled cols and treatment
# Create a matching object with matching using the nearest model
match_nearest[[i]] <- matchit(formula = college ~ . - college - student_ppnscal,
data = sampled_data,
method = "nearest",
distance = "glm",
link = "logit",
discard = "control",
replace = FALSE,
ratio = 2)
## Summary to store models
summary_df[[i]] <- summary(match_nearest[[i]])
matched_data <- match.data(match_nearest[[i]]) ## creating matched data
# Fit linear model to calculate ATT
lm_nearest <- lm(student_ppnscal ~ . - student_ppnscal, data = sampled_data)
ATT_nearest <- coef(lm_nearest)["college"] # Extract ATT
att_list[i] <- ATT_nearest # Store ATT in the list
## SMD
df_all <- as.data.frame(summary_df[[i]]$sum.all)
df_matched <- as.data.frame(summary_df[[i]]$sum.matched)
# Calculate mean percent improvement in SMD
if (i > 1) {
mean_smd_all <- mean(df_all$`Std. Mean Diff.`)
mean_smd_matched <- mean(df_matched$`Std. Mean Diff.`)
mean_pct_improvement[i] <- ((mean_smd_matched - mean_smd_all) / mean_smd_matched) * 100
prop_balanced_covariates[i] <- nrow(df_matched %>% filter(`Std. Mean Diff.` <= 0.1)) / nrow(df_matched)
}
}
# Create a dataframe to store simulation results
results_df <- data.frame(
simulation = 1:num_simulations,
num_covariates = unlist(num_covariates),
prop_balanced_covariates = prop_balanced_covariates,
att = att_list,
mean_pct_improvement = mean_pct_improvement
)
return(list(match_nearest = match_nearest, results_df = results_df))
}
# calling function
result_nearest <- simulate_and_get_att_nearest(num_simulations = 10000)
##########################
## Simulation I: OPTIMAL #
##########################
set.seed(3141)
simulate_and_get_att_optimal <- function(num_simulations) {
## Initializing empty lists
att_list <- numeric(num_simulations)
prop_balanced_covariates <- numeric(num_simulations)
summary_df <- list()
num_covariates <- list()
mean_pct_improvement <- numeric(num_simulations)
# Simulate samples, perform propensity score matching, and calculate ATT
for (i in 1:num_simulations) {
num_covariates[[i]] <- sample(1:123, 1) # Randomly choose the number of covariates
available_cols <- setdiff(names(baseline_df), c('college', 'student_ppnscal'))
sample_size <- min(num_covariates[[i]] + 2, length(available_cols))
sampled_cols <- sample(available_cols, sample_size)
sampled_data <- baseline_df[, c(sampled_cols, "college", "student_ppnscal"), drop = FALSE] # sampled df with sampled cols, treatment and outcome
# Create a matching object with matching using the optimal model
match_optimal <- matchit(formula = college ~ . - college - student_ppnscal,
data = sampled_data,
method = "optimal",
distance = "glm",
link = "logit",
discard = "control",
replace = FALSE,
ratio = 2)
## Summary to store models
summary_df[[i]] <- summary(match_optimal)
matched_data <- match.data(match_optimal) ## creating matched data
# Fit linear model to calculate ATT
lm_optimal <- lm(student_ppnscal ~ . - student_ppnscal, data = sampled_data)
ATT_optimal <- coef(lm_optimal)["college"] # Extract ATT
att_list[i] <- ATT_optimal # Store ATT in the list
## SMD
df_all <- as.data.frame(summary_df[[i]]$sum.all)
df_matched <- as.data.frame(summary_df[[i]]$sum.matched)
# Calculate mean percent improvement in SMD
if (i > 1) {
mean_smd_all <- mean(df_all$`Std. Mean Diff.`)
mean_smd_matched <- mean(df_matched$`Std. Mean Diff.`)
mean_pct_improvement[i] <- ((mean_smd_matched - mean_smd_all) / mean_smd_matched) * 100
prop_balanced_covariates[i] <- nrow(df_matched %>% filter(`Std. Mean Diff.` <= 0.1)) / nrow(df_matched)
}
}
# Create a dataframe to store simulation results
results_df <- data.frame(
simulation = 1:num_simulations,
num_covariates = unlist(num_covariates),
prop_balanced_covariates = prop_balanced_covariates,
att = att_list,
mean_pct_improvement = mean_pct_improvement
)
return(results_df)
}
# calling function
result_optimal <- simulate_and_get_att_nearest(num_simulations = 100)
## I do the first part with the simulation in another R script and import the function here
head(result_nearest$results_df,10)
## Number of simulations for which the proportion of balanced covariates is above 70%
sum(result_nearest$results_df$prop_balanced_covariates > 0.70)
## Number of simulations for which the proportion of balanced covariates is above 60%
sum(result_nearest$results_df$prop_balanced_covariates > 0.60)
## Number of simulations for which the proportion of balanced covariates is above 50%
sum(result_nearest$results_df$prop_balanced_covariates > 0.50)
print("ATT summary across simulations for results_nearest")
summary(result_nearest$results_df$att)
# Plotting distribution of ATT across simulations
ggplot(result_nearest$results_df, aes(x = att)) +
geom_density(fill = "skyblue", color = "black") +
labs(title = "Density Plot of ATT", x = "ATT") +
theme_minimal() +
xlim(-1, 2)
# Create a data frame for plotting
plot_data <- data.frame(
ATT = result_nearest$results_df$att,
Balanced_Covariate_Proportion = result_nearest$results_df$prop_balanced_covariates
)
# Create a scatterplot
ggplot(plot_data, aes(x = ATT, y = Balanced_Covariate_Proportion)) +
geom_point(alpha = 0.5) +
labs(x = "ATT", y = "Proportion of Balanced Covariates") +
ggtitle("Scatterplot of Proportion of Balanced Covariates vs. ATT") +
xlim(0, 1.5) +
ylim(0, 1.5) +
theme(plot.title = element_text(hjust = 0.5, face = "bold"))
# Randomly sample 10 indices from the list of models
sampled_indices <- sample(seq_along(result_nearest$match_nearest), size = 10,
replace = FALSE)
random_models <- result_nearest$match_nearest[sampled_indices]
# Function to plot the balance of covariates in each model
plot_summary <- function(model) {
plot(summary(model))
}
# Apply the plot_summary function to each model in random_models
plots_list <- lapply(random_models, plot_summary)
head(result_optimal$results_df, 10)
# Print summary for result_nearest
print("Summary proportion of balanced covariates for result_nearest:")
summary(result_nearest$results_df$prop_balanced_covariates)
# Print summary for result_optimal
print("Summary proportion of balanced covariates for result_optimal:")
summary(result_optimal$results_df$prop_balanced_covariates)
# Print summary for result_nearest
print("Summary or mean percent improvement for result_nearest:")
print(summary(result_nearest$results_df$mean_pct_improvement))
# Print summary for result_optimal
print("Summary of mean percent improvement for result_optimal:")
print(summary(result_optimal$results_df$mean_pct_improvement))
# Randomly sample 10 indices from the list of models
sampled_indices <- sample(seq_along(result_optimal$match_optimal), size = 10,
replace = FALSE)
random_models <- result_optimal$match_optimal[sampled_indices]
head(result_optimal$results_df, 10)
# Print summary for result_nearest
print("Summary proportion of balanced covariates for result_nearest:")
summary(result_nearest$results_df$prop_balanced_covariates)
# Print summary for result_optimal
print("Summary proportion of balanced covariates for result_optimal:")
summary(result_optimal$results_df$prop_balanced_covariates)
# Print summary for result_nearest
print("Summary or mean percent improvement for result_nearest:")
print(summary(result_nearest$results_df$mean_pct_improvement))
# Print summary for result_optimal
print("Summary of mean percent improvement for result_optimal:")
print(summary(result_optimal$results_df$mean_pct_improvement))
# Randomly sample 10 indices from the list of models
sampled_indices <- sample(seq_along(result_optimal$match_optimal), size = 10,
replace = FALSE)
# Randomly sample 10 indices from the list of models
sampled_indices <- sample(seq_along(result_optimal$match_optimal), size = 10,
replace = FALSE)
random_models <- result_optimal$match_optimal[sampled_indices]
# Function to plot the balance of covariates in each model
plot_summary <- function(model) {
plot(summary(model))
}
# Apply the plot_summary function to each model in random_models
plots_list <- lapply(random_models, plot_summary)
# Apply the plot_summary function to each model in random_models
plots_list <- lapply(random_models, plot_summary)
result_optimal$match_nearest
summary(result_nearestl$results_df$prop_balanced_covariates)
# Print summary for result_optimal
print("Summary proportion of balanced covariates for result_optimal:")
summary(result_optimal$results_df$prop_balanced_covariates)
# Print summary for result_nearest
print("Summary or mean percent improvement for result_nearest:")
head(result_optimal$results_df, 10)
# Print summary for result_nearest
print("Summary proportion of balanced covariates for result_nearest:")
summary(result_nearestl$results_df$prop_balanced_covariates)
summary(result_nearest$results_df$prop_balanced_covariates)
# Print summary for result_optimal
print("Summary proportion of balanced covariates for result_optimal:")
summary(result_optimal$results_df$prop_balanced_covariates)
# Print summary for result_nearest
print("Summary or mean percent improvement for result_nearest:")
print(summary(result_nearest$results_df$mean_pct_improvement))
# Print summary for result_optimal
print("Summary of mean percent improvement for result_optimal:")
print(summary(result_optimal$results_df$mean_pct_improvement))
# Randomly sample 10 indices from the list of models
sampled_indices <- sample(seq_along(result_optimal$match_optimal), size = 10,
replace = FALSE)
tinytex::reinstall_tinytex(repository = "illinois")
# Randomly sample 10 indices from the list of models
sampled_indices <- sample(seq_along(result_nearest$match_nearest), size = 10,
replace = FALSE)
# Randomly sample 10 indices from the list of models
sampled_indices <- sample(seq_along(result_nearest$match_nearest), size = 10,
replace = FALSE)
random_models <- result_nearest$match_nearest[sampled_indices]
# Function to plot the balance of covariates in each model
plot_summary <- function(model) {
plot(summary(model))
}
# Apply the plot_summary function to each model in random_models
plots_list <- lapply(random_models, plot_summary)
# Apply the plot_summary function to each model in random_models
plots_list <- lapply(random_models, plot_summary)
## I read that supposedly extragrid converts your plots to grobs (https://stackoverflow.com/questions/36901632/r-change-list-of-ggplot-objects-into-a-list-of-grobs-that-grid-arrange-will-ac), but it doesn't. I couldn't figure it out. This code below doesn't work.
##grid.arrange(grobs = plots_list)
##grid.arrange(grobs = plots_list, ncol = 10)
```
# Create a scatterplot
ggplot(plot_data, aes(x = ATT, y = Balanced_Covariate_Proportion)) +
geom_point(alpha = 0.5) +
labs(x = "ATT", y = "Proportion of Balanced Covariates") +
ggtitle("Scatterplot of Proportion of Balanced Covariates vs. ATT") +
xlim(0, 1.5) +
ylim(0, 1.5) +
theme(plot.title = element_text(hjust = 0.5, face = "bold"))
# Create a scatterplot
ggplot(plot_data, aes(x = ATT, y = Balanced_Covariate_Proportion)) +
geom_point(alpha = 0.5) +
labs(x = "ATT", y = "Proportion of Balanced Covariates") +
ggtitle("Scatterplot of Proportion of Balanced Covariates vs. ATT") +
xlim(0, 1.5) +
ylim(0, 1.5) +
theme(plot.title = element_text(hjust = 0.5, face = "bold"))
# Create a data frame for plotting
plot_data <- data.frame(
ATT = result_nearest$results_df$att,
Balanced_Covariate_Proportion = result_nearest$results_df$prop_balanced_covariates
)
# Create a scatterplot
ggplot(plot_data, aes(x = ATT, y = Balanced_Covariate_Proportion)) +
geom_point(alpha = 0.5) +
labs(x = "ATT", y = "Proportion of Balanced Covariates") +
ggtitle("Scatterplot of Proportion of Balanced Covariates vs. ATT") +
xlim(0, 1.5) +
ylim(0, 1.5) +
theme(plot.title = element_text(hjust = 0.5, face = "bold"))
## Number of simulations for which the proportion of balanced covariates is above 60%
sum(result_nearest$results_df$prop_balanced_covariates > 0.60)
## Number of simulations for which the proportion of balanced covariates is above 50%
sum(result_nearest$results_df$prop_balanced_covariates > 0.50)
print("ATT summary across simulations for results_nearest")
summary(result_nearest$results_df$att)
# Plotting distribution of ATT across simulations
ggplot(result_nearest$results_df, aes(x = att)) +
geom_density(fill = "skyblue", color = "black") +
labs(title = "Density Plot of ATT", x = "ATT") +
theme_minimal() +
xlim(-1, 2)
summary_df <- summary(match_nearest)
df <- as.data.frame(summary_df$sum.matched)
covariates_logistic <- c("student_GPA", "student_FamTalk",
"student_Newspaper", "parent_Vote",
"parent_HHInc", "parent_Employ", "parent_OwnHome")
formula_logistic <- as.formula(paste("college ~",
paste(covariates_logistic, collapse = " + ")))
match_nearest <- matchit(formula = formula_logistic,
data = ypsps,
method = "nearest",
distance = "glm",
link = "logit",
discard = "control",
replace = FALSE,
ratio = 2)
bal.tab(match_nearest, un = TRUE, stats = c("m", "v", "ks"))
# estimate ATT
matching_att <- match.data(match_nearest)
dependent_variable <- "student_ppnscal"
independent_variables <- c("college", covariates_logistic)
formula_att <- as.formula(paste(dependent_variable, "~",
paste(independent_variables, collapse = " + ")))
lm_att <- lm(formula = formula_att,
data = matching_att,
weights = weights)
## get ATT
ATT_nearest <- coef(lm_att)["college"] # Extract ATT
ATT_nearest
# Plot the balance for the top 10 covariates
plot(summary(match_nearest))
# Report the balance of the p-scores across both the treatment and control groups,
## and using a threshold of standardized mean difference of p-score <= .1,
## report the number of covariates that meet the balance threshold
summary(match_nearest)$sum.matched %>% as.data.frame()
summary_df <- summary(match_nearest)
df <- as.data.frame(summary_df$sum.matched)
## report the balance of the p-scores across both the treatment and control groups,
ypsps$pscore <- match_nearest$distance
ypsps %>% group_by(college) %>% summarize(mean(pscore))
## Using a threshold of standardized mean difference of p-score $\leq .1$,
## report the number of covariates that meet that balance threshold.
num_balanced_covariates  <- nrow(df %>% filter(`Std. Mean Diff.` <= 0.1))
num_balanced_covariates ## 3
# Function to simulate samples, perform t-test, and store results
simulate_and_visualize <- function(ypsps, num_simulations = 10000) {
# Initialize empty vectors to store results
p_values <- numeric(num_simulations)
diff_means <- numeric(num_simulations)
# Simulate samples, perform t-test, and store results
for (i in 1:num_simulations) {
# Draw sample from df
ypsps$treatment <- sample(c("Control", "Treatment"), nrow(ypsps),
replace = TRUE, prob = c(0.5, 0.5))
# Perform t-test
t_test_result <- t.test(ypsps$student_button ~ ypsps$treatment)
# Extract p-value and difference in means from t-test result
p_values[i] <- t_test_result$p.value
diff_means[i] <- t_test_result$estimate[2] - t_test_result$estimate[1]
}
# Create a dataframe to store simulation results
results_df <- data.frame(
simulation = 1:num_simulations,
p_value = p_values,
diff_in_means = diff_means
)
# Return the results dataframe
return(results_df)
}
simulation_results <- simulate_and_visualize(ypsps, num_simulations = 10000)
head(simulation_results, 20)
# Estimate mean of diff in means across simulatins
summary(simulation_results$diff_in_means, na.rm = T)
# Plot distribution of diff-in-means across simulations
ggplot(simulation_results, aes(x = diff_in_means)) +
geom_density(fill = "skyblue", color = "black") +
labs(title = "Distribution of Mean Difference",
x = "Mean Difference",
y = "Density")
# Estimate and print proportion of significant p-values across simulations
sum(simulation_results$p_value < 0.05) / nrow(simulation_results) ## 5%
# Print summary for result_optimal
print("Summary of mean percent improvement for result_optimal:")
print(summary(result_optimal$results_df$mean_pct_improvement))
rm(list = ls())
# libraries
xfun::pkg_attach2(c("tidyverse",
"dplyr",
"here",
"MatchIt",
"gridExtra",
"ggplot2",
"optmatch",
"cobalt"))
options(scipen = 999)
# Load ypsps data
ypsps <- read_csv('/Users/brenda/github/Computational-Social-Science-Projects/Project 6/ypsps.csv')
head(ypsps)
nrow(ypsps)
##########################
## Simulation I: NEAREST #
##########################
# Remove post-treatment covariates
filtered_vars <- names(ypsps)[!grepl("1973|1982", names(ypsps))]
baseline_df <- ypsps %>% select(all_of(filtered_vars)) %>%
filter(!is.na(parent_GPHighSchoolPlacebo))
baseline_df <- baseline_df[complete.cases(baseline_df), ]
## generating df with complete cases for function used below
set.seed(3141)
simulate_and_get_att_nearest <- function(num_simulations) {
## Initializing empty lists
att_list <- numeric(num_simulations)
prop_balanced_covariates <- numeric(num_simulations)
summary_df <- list()
num_covariates <- list()
mean_pct_improvement <- numeric(num_simulations)
match_nearest <- vector("list", length = num_simulations)
# Simulate samples, perform propensity score matching, and calculate ATT
for (i in 1:num_simulations) {
num_covariates[[i]] <- sample(5:20, 1) # Randomly choose the number of covariates
available_cols <- setdiff(names(baseline_df), c('college', 'student_ppnscal'))
sample_size <- min(num_covariates[[i]] + 2, length(available_cols))
sampled_cols <- sample(available_cols, sample_size)
sampled_data <- baseline_df[, c(sampled_cols, "college", "student_ppnscal"), drop = FALSE]
# sampled df with sampled cols and treatment
# Create a matching object with matching using the nearest model
match_nearest[[i]] <- matchit(formula = college ~ . - college - student_ppnscal,
data = sampled_data,
method = "nearest",
distance = "glm",
link = "logit",
discard = "control",
replace = FALSE,
ratio = 2)
## Summary to store models
summary_df[[i]] <- summary(match_nearest[[i]])
matched_data <- match.data(match_nearest[[i]]) ## creating matched data
# Fit linear model to calculate ATT
lm_nearest <- lm(student_ppnscal ~ . - student_ppnscal, data = sampled_data)
ATT_nearest <- coef(lm_nearest)["college"] # Extract ATT
att_list[i] <- ATT_nearest # Store ATT in the list
## SMD
df_all <- as.data.frame(summary_df[[i]]$sum.all)
df_matched <- as.data.frame(summary_df[[i]]$sum.matched)
# Calculate mean percent improvement in SMD
if (i > 1) {
mean_smd_all <- mean(df_all$`Std. Mean Diff.`)
mean_smd_matched <- mean(df_matched$`Std. Mean Diff.`)
mean_pct_improvement[i] <- ((mean_smd_matched - mean_smd_all) / mean_smd_matched) * 100
prop_balanced_covariates[i] <- nrow(df_matched %>% filter(`Std. Mean Diff.` <= 0.1)) / nrow(df_matched)
}
}
# Create a dataframe to store simulation results
results_df <- data.frame(
simulation = 1:num_simulations,
num_covariates = unlist(num_covariates),
prop_balanced_covariates = prop_balanced_covariates,
att = att_list,
mean_pct_improvement = mean_pct_improvement
)
return(list(match_nearest = match_nearest, results_df = results_df))
}
# calling function
result_nearest <- simulate_and_get_att_nearest(num_simulations = 10)
##########################
## Simulation I: OPTIMAL #
##########################
set.seed(3141)
simulate_and_get_att_optimal <- function(num_simulations) {
## Initializing empty lists
att_list <- numeric(num_simulations)
prop_balanced_covariates <- numeric(num_simulations)
summary_df <- list()
num_covariates <- list()
mean_pct_improvement <- numeric(num_simulations)
# Simulate samples, perform propensity score matching, and calculate ATT
for (i in 1:num_simulations) {
num_covariates[[i]] <- sample(1:123, 1) # Randomly choose the number of covariates
available_cols <- setdiff(names(baseline_df), c('college', 'student_ppnscal'))
sample_size <- min(num_covariates[[i]] + 2, length(available_cols))
sampled_cols <- sample(available_cols, sample_size)
sampled_data <- baseline_df[, c(sampled_cols, "college", "student_ppnscal"), drop = FALSE] # sampled df with sampled cols, treatment and outcome
# Create a matching object with matching using the optimal model
match_optimal <- matchit(formula = college ~ . - college - student_ppnscal,
data = sampled_data,
method = "optimal",
distance = "glm",
link = "logit",
discard = "control",
replace = FALSE,
ratio = 2)
## Summary to store models
summary_df[[i]] <- summary(match_optimal)
matched_data <- match.data(match_optimal) ## creating matched data
# Fit linear model to calculate ATT
lm_optimal <- lm(student_ppnscal ~ . - student_ppnscal, data = sampled_data)
ATT_optimal <- coef(lm_optimal)["college"] # Extract ATT
att_list[i] <- ATT_optimal # Store ATT in the list
## SMD
df_all <- as.data.frame(summary_df[[i]]$sum.all)
df_matched <- as.data.frame(summary_df[[i]]$sum.matched)
# Calculate mean percent improvement in SMD
if (i > 1) {
mean_smd_all <- mean(df_all$`Std. Mean Diff.`)
mean_smd_matched <- mean(df_matched$`Std. Mean Diff.`)
mean_pct_improvement[i] <- ((mean_smd_matched - mean_smd_all) / mean_smd_matched) * 100
prop_balanced_covariates[i] <- nrow(df_matched %>% filter(`Std. Mean Diff.` <= 0.1)) / nrow(df_matched)
}
}
# Create a dataframe to store simulation results
results_df <- data.frame(
simulation = 1:num_simulations,
num_covariates = unlist(num_covariates),
prop_balanced_covariates = prop_balanced_covariates,
att = att_list,
mean_pct_improvement = mean_pct_improvement
)
return(list(match_optimal = match_optimal, results_df = results_df))
}
# calling function
result_optimal <- simulate_and_get_att_optimal(num_simulations = 10)
result_optimal$match_optimal
